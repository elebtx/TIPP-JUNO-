import numpy as np
import matplotlib.pyplot as plt  # plots des spectres / différences relatives


# 0) Paramètres "expérience" -> pour convertir en N d'événements

# Baseline
L_KM = 52.5
L_CM = L_KM * 1e5  # conversion km -> cm (car flux ~ 1/(4πL^2) et L doit matcher les unités cm)

# Exposition / détecteur (valeurs type JUNO, modifiables)
P_TH_GW = 36.0          # puissance thermique totale [GWth]
DETECTOR_MASS_KTON = 20.0  # masse fiducielle en kilotonnes (ordre de grandeur JUNO)
LIVE_TIME_YEARS = 6.0      # temps de prise de données
EFFICIENCY = 0.80       # efficacité globale IBD (détection+cuts etc.) -> facteur multiplicatif
DELTA_E_BIN = 0.02      # largeur de bin en MeV pour "nombre de coups" (bins petits = plus fin)

# Protons libres (ordre de grandeur) : ~6.7e31 / kton (à ajuster selon scintillateur)
# -> c'est le nombre de cibles (p libres) participant à ν̄_e + p -> e+ + n
N_P_PER_KTON = 6.7e31
N_TARGET = N_P_PER_KTON * DETECTOR_MASS_KTON  # nombre total de protons cibles

# Conversion temps
SECONDS_PER_YEAR = 365.25 * 24 * 3600  # année moyenne en secondes
LIVE_TIME_S = LIVE_TIME_YEARS * SECONDS_PER_YEAR  # durée totale en secondes

# Conversion puissance
P_TH_W = P_TH_GW * 1e9  # GW -> W

# Energies libérées par fission (MeV) typiques (à ajuster si tu veux)
# -> utile car le taux de fission = puissance / énergie par fission
E_FISS_MEV = {
    "U235": 201.92,
    "U238": 205.52,
    "Pu239": 209.99,
    "Pu241": 213.60,
}
MEV_TO_J = 1.602176634e-13  # J / MeV (conversion exacte CODATA)


# 1) Spectres antineutrinos par fission
#    lambda_i(E) = exp( a0 + a1 E + ... + a5 E^5 )

COEFFS = {
    "U235":  [3.217,  -3.111,  1.395,  -3.690e-1,  4.445e-2,  -2.053e-3],
    "U238":  [4.833e-1,  1.927e-1, -1.283e-1, -6.762e-3,  2.233e-3, -1.536e-4],
    "Pu239": [6.413,  -7.432,  3.535,  -8.820e-1,  1.025e-1, -4.550e-3],
    "Pu241": [3.251,  -3.204,  1.428,  -3.675e-1,  4.254e-2, -1.896e-3],
}  # coeffs des fits (paramétrisation exp(polynôme))

FISSION_FRACTIONS = {
    "U235": 0.577,
    "U238": 0.076,
    "Pu239": 0.295,
    "Pu241": 0.052,
}  # fractions de fission (pondèrent les isotopes dans le flux total)

def antinu_spectrum_per_fission(E, isotope):
    """dN/dE par fission [1/(MeV fission)]"""
    # E est en MeV ici
    a = np.array(COEFFS[isotope], dtype=float)     # coefficients a0..a5
    powers = np.vstack([E**k for k in range(6)])   # matrice [E^0, E^1, ..., E^5]
    poly = np.dot(a, powers)                       # calcule a0 + a1 E + ... + a5 E^5
    return np.exp(poly)                            # spectre >0 (exp), unité 1/(MeV fission)

def total_flux_per_fission(E):
    """Somme pondérée des isotopes [1/(MeV fission)]"""
    # combine les isotopes avec leurs fractions de fission
    tot = np.zeros_like(E)
    for iso, frac in FISSION_FRACTIONS.items():
        tot += frac * antinu_spectrum_per_fission(E, iso)
    return tot

def avg_energy_per_fission_J():
    """E_fiss moyenne pondérée -> Joules/fission"""
    # moyenne pondérée de l'énergie libérée par fission selon les fractions isotopiques
    e_mev = 0.0
    for iso, frac in FISSION_FRACTIONS.items():
        e_mev += frac * E_FISS_MEV[iso]
    return e_mev * MEV_TO_J  # conversion en Joules

def fission_rate_per_s():
    """Nombre de fissions/s"""
    # fissions/s = puissance(W) / énergie par fission(J)
    return P_TH_W / avg_energy_per_fission_J()


# 2) Section efficace IBD (approx simple)

ME = 0.511   # MeV (masse e-/e+)
DELTA = 1.293  # MeV (Mn - Mp)

def sigma_ibd(E):
    """
    Approx: sigma ~ 1e-43 * p_e * E_e  [cm^2]
    E en MeV (E_nu)
    """
    # cinématique : E_e ≈ E_ν - Δ
    Ee = E - DELTA
    pe2 = Ee**2 - ME**2  # p^2 = E^2 - m^2

    sigma = np.zeros_like(E)  # par défaut 0 (en dessous du seuil)
    mask = (Ee > ME) & (E >= 1.806)  # condition IBD : positron réel + seuil Eν

    Ee_m = Ee[mask]
    pe = np.sqrt(pe2[mask])

    sigma[mask] = 1e-43 * pe * Ee_m  # cm^2 (formule “simple”)
    return sigma


# 3) Oscillations : forme "article" (Δm_ee^2 + φ⊙) -> NO/IO visible

SIN2_TH12 = 0.307
SIN2_TH13 = 0.024

DM21 = 7.54e-5      # eV^2
DMEE = 2.43e-3      # eV^2 (Δm^2_ee) pris positif (définition)

def pee_article(E_nu, ordering="NO"):
    """
    P_ee en vide sous la forme:
      P = 1 - 1/2 sin^2(2θ13)[1 - sqrtA cos(2Δee ± φ⊙)] - P_solar
    avec sqrtA = sqrt(1 - sin^2(2θ12) sin^2 Δ21)
    et φ⊙ défini via sinφ, cosφ (info de quadrant).
    NO => + ; IO => -
    Réf: Minakata et al. (hep-ph/0701151), Eq.(5)-(6). :contentReference[oaicite:1]{index=1}
    """
    # on bosse en sin^2 et cos^2 directement (plus stable numériquement)
    s12_2 = SIN2_TH12
    c12_2 = 1.0 - s12_2
    s13_2 = SIN2_TH13
    c13_2 = 1.0 - s13_2

    # sin^2(2θ) = 4 s^2 c^2
    sin2_2th12 = 4.0 * s12_2 * c12_2
    sin2_2th13 = 4.0 * s13_2 * c13_2

    # conversion MeV -> GeV car le facteur 1.267 est calibré pour (eV^2, km, GeV)
    E_GeV = E_nu / 1000.0

    # phases d’oscillation (Δ = 1.267 Δm^2 L/E)
    D21 = 1.267 * DM21 * L_KM / E_GeV
    Dee = 1.267 * DMEE * L_KM / E_GeV
    absDee = np.abs(Dee)  # partie “|Δee|” (le signe hiérarchie est dans sign)

    # solar term P⊙ = sin^2(2θ12) c13^4 sin^2 Δ21
    # (dans ton écriture : (c13_2**2) = c13^4)
    P_solar = sin2_2th12 * (c13_2**2) * (np.sin(D21)**2)

    # sqrtA = sqrt(1 - sin^2(2θ12) sin^2 Δ21)
    A = 1.0 - sin2_2th12 * (np.sin(D21)**2)
    A = np.maximum(A, 1e-15)  # évite sqrt(A<0) à cause des erreurs flottantes
    sqrtA = np.sqrt(A)

    # φ⊙ via Eq.(6)
    # sin φ⊙ = [c12^2 sin(2 s12^2 Δ21) - s12^2 sin(2 c12^2 Δ21)] / sqrtA
    # cos φ⊙ = [c12^2 cos(2 s12^2 Δ21) + s12^2 cos(2 c12^2 Δ21)] / sqrtA
    # arctan2 garde le bon quadrant (important pour NO/IO)
    sinphi = (c12_2 * np.sin(2.0 * s12_2 * D21) - s12_2 * np.sin(2.0 * c12_2 * D21)) / sqrtA
    cosphi = (c12_2 * np.cos(2.0 * s12_2 * D21) + s12_2 * np.cos(2.0 * c12_2 * D21)) / sqrtA
    phi = np.arctan2(sinphi, cosphi)

    # NO/NH => +1, IO/IH => -1 (ton “± φ⊙”)
    sign = +1.0 if ordering.upper() in ["NO", "NH", "NORMAL"] else -1.0

    # atmospheric-like term: 1/2 sin^2(2θ13)[1 - sqrtA cos(2Δee ± φ⊙)]
    P_atm = 0.5 * sin2_2th13 * (1.0 - sqrtA * np.cos(2.0 * absDee + sign * phi))

    # proba finale
    pee = 1.0 - P_solar - P_atm
    return np.clip(pee, 0.0, 1.0)

def pee_theta12_only(E_nu):
    """Mode 'θ12 only' (en pratique θ13=0)"""
    # ici on garde seulement l’oscillation “solaire” (Δm21^2, θ12)
    s12_2 = SIN2_TH12
    c12_2 = 1.0 - s12_2
    sin2_2th12 = 4.0 * s12_2 * c12_2

    E_GeV = E_nu / 1000.0
    D21 = 1.267 * DM21 * L_KM / E_GeV

    pee = 1.0 - sin2_2th12 * (np.sin(D21) ** 2)
    return np.clip(pee, 0.0, 1.0)


# 4) Taux d'événements : dN/dE puis N par bin

def flux_at_detector_per_MeV_per_s(E):
    """
    Flux à la distance L :
      dΦ/dE = (fission_rate) * (dN/dE par fission) / (4πL^2)
    unités: [1/(MeV s cm^2)]
    """
    fr = fission_rate_per_s()  # fissions/s
    # total_flux_per_fission(E) est en 1/(MeV fission)
    # donc fr * total_flux_per_fission(E) -> 1/(MeV s)
    # puis / (4πL^2) -> 1/(MeV s cm^2)
    return fr * total_flux_per_fission(E) / (4.0 * np.pi * L_CM**2)

def dN_dE_events_per_MeV(E, mode="no", ordering="NO"):
    """
    dN/dE = Φ(E) * σ(E) * P_ee(E) * N_target * eff * T
    unités: [events / MeV] (sur toute l'exposition)
    """
    phi = flux_at_detector_per_MeV_per_s(E)       # 1/(MeV s cm^2)
    sig = sigma_ibd(E)                            # cm^2
    # phi*sig -> 1/(MeV s) (le cm^2 s’annule)
    # puis × N_TARGET × EFFICIENCY × LIVE_TIME_S -> events/MeV sur toute l’expo

    if mode == "no":
        pee = np.ones_like(E)  # pas d’oscillation => P_ee=1
    elif mode == "th12":
        pee = pee_theta12_only(E)  # uniquement θ12/Δm21
    elif mode == "full":
        pee = pee_article(E, ordering=ordering)  # formule complète sensible NO/IO
    else:
        raise ValueError("mode must be 'no', 'th12', or 'full'")

    return phi * sig * pee * N_TARGET * EFFICIENCY * LIVE_TIME_S

def N_per_bin(E_centers, dE, mode="no", ordering="NO"):
    """Nombre d'événements dans chaque bin ~ (dN/dE)*dE"""
    # ici on approxime N_bin ≈ (dN/dE évalué au centre) × largeur du bin
    return dN_dE_events_per_MeV(E_centers, mode=mode, ordering=ordering) * dE


# 5) Plots en fonction de E 

def plot_counts_vs_E():
    # Grille en énergie (centres de bin)
    E_min, E_max = 1.80, 8.50      # fenêtre typique d’analyse (on peut changer)
    dE = DELTA_E_BIN               # largeur de bin (MeV)
    E = np.arange(E_min + dE/2, E_max, dE)  # centres : [E_min+dE/2, ..., <E_max]

    # 4 courbes : sans osc, θ12 only, et complet en NO/IO
    y_no   = N_per_bin(E, dE, mode="no")
    y_th12 = N_per_bin(E, dE, mode="th12")
    y_noo  = N_per_bin(E, dE, mode="full", ordering="NO")
    y_io   = N_per_bin(E, dE, mode="full", ordering="IO")

    plt.figure(figsize=(9.0, 5.6))
    plt.plot(E, y_no,   "k--", linewidth=1, label="Non oscillation")
    plt.plot(E, y_th12, "k-",  linewidth=1, label=r"$\theta_{12}$ oscillation")
    plt.plot(E, y_noo,  color="blue", linewidth=1, label="Normal ordering (NO)")
    plt.plot(E, y_io,   color="red",  linewidth=1, label="Inverted ordering (IO)")
    plt.xlabel(r"$E_\nu$ (MeV)")
    plt.ylabel(f"Events per bin (ΔE = {dE:.3f} MeV) over {LIVE_TIME_YEARS:g} years")
    plt.grid(True, alpha=0.25)
    plt.legend(loc="upper right")
    plt.tight_layout()
    plt.show()

    # Optionnel : différence relative (IO-NO)/NO vs E
    # utile pour voir la modulation hiérarchie “en pourcentage” plutôt qu’en valeur absolue
    eps = 1e-30  # évite division par 0 si un bin a ~0 events
    rel = (y_io - y_noo) / (y_noo + eps)

    plt.figure(figsize=(9.0, 3.8))
    plt.plot(E, rel, "k", linewidth=0.3)
    plt.axhline(0.0, color="gray", linewidth=1)
    plt.xlabel(r"$E_\nu$ (MeV)")
    plt.ylabel(r"$(IO-NO)/NO$")
    plt.grid(True, alpha=0.25)
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    plot_counts_vs_E()
